## uC/Modbus（uC-Modbus）在本工程的移植说明（STM32F4 + FreeRTOS）

本文档描述 **本仓库当前工程** 是如何把 uC/Modbus 接到 STM32F407 + FreeRTOS 上的，以及如果你要把它迁移到别的 STM32 工程/别的 UART/别的定时器时，需要改哪些点。

上游仓库参考：[`weston-embedded/uC-Modbus`](https://github.com/weston-embedded/uC-Modbus)

---

### 1. 与上游 uC-Modbus 的关系/差异点（你这份工程改了哪里）

uC/Modbus 核心协议栈主要在 `Middlewares/Third_Party/uC-Modbus/Source/`，该部分一般尽量保持与上游一致；本工程的“移植工作”主要集中在三类文件：

- **OS 适配（FreeRTOS）**
  - `Middlewares/Third_Party/uC-Modbus/OS/FreeRTOS/mb_os.c`
  - `Middlewares/Third_Party/uC-Modbus/OS/FreeRTOS/mb_os.h`
- **MCU/板级适配（STM32F4 + 串口 + RTU 定时器）**
  - `Middlewares/Third_Party/uC-Modbus/Ports/STM32F4/mb_bsp.c`
  - `Middlewares/Third_Party/uC-Modbus/Ports/STM32F4/mb_CPU.h`
- **工程侧配置与寄存器映射（Template 目录在本工程直接作为配置源使用）**
  - `Middlewares/Third_Party/uC-Modbus/Cfg/Template/mb_cfg.h`
  - `Middlewares/Third_Party/uC-Modbus/Cfg/Template/mbreg.h`
  - `Middlewares/Third_Party/uC-Modbus/Cfg/Template/mb_data.c`

换句话说：如果你未来要“升级/替换”上游 uC/Modbus 的 `Source/`，请优先保留/迁移上述三个区域的改动。

---

### 2. uC/Modbus 在本工程的运行机制（抓住关键链路）

#### 2.1 初始化与通道配置

1) 应用调用 `MB_Init(freq_hz)`（本工程示例：`MB_Init(1000)`，表示 **RTU 定时基准 1000Hz=1ms**）。

2) `MB_Init()` 内部会：

- 初始化通道表 `MB_ChTbl[]`
- 调用 `MB_OS_Init()` 初始化 OS 适配层
- 如果启用 RTU：调用 `MB_RTU_TmrInit()` 初始化 RTU 定时器

3) 应用调用 `MB_CfgCh(...)` 为每个通道配置：

- 节点地址（node_addr）
- Master/Slave 模式
- RTU/ASCII 模式
- 串口号（port_nbr）
- 波特率/校验/数据位/停止位
- Master 超时 `rx_timeout`（注意单位）

本工程示例在 `UserApp/main.c` 中配置了：

- 485 从机：`serial_RS4851` @ 9600 / RTU / slave
- 主机：`serial_UART` @ 19200 / RTU / master
- 232 主机：`serial_RS232` @ 19200 / RTU / master

#### 2.2 串口接收：从“每字节中断”到“整帧处理”

在本工程的 STM32F4 端口中（`Ports/STM32F4/mb_bsp.c`）：

- `MB_CommPortCfg()` 会调用 `serial_begin_cof()` 初始化串口，并通过
  - `serial_attachRxInterrupt(serialX, MB_CommRxISR_X_Handler)`
  - `serial_attachTxInterrupt(serialX, MB_CommTxISR_X_Handler)`
  挂接收发中断回调。

当 UART 收到 1 个字节时，`MB_CommRxISR_X_Handler(char c)` 会调用：

- `MB_RxByte(pch, c)`：把字节塞进协议栈的接收缓冲，同时 **重置 RTU 帧间隔计时器**。

当 RTU 定时器判定“帧间隔已满足”（计数到 0）时，会触发：

- `MB_OS_RxSignal(pch)`：通知 OS 层“该通道有一帧需要处理”。

OS 层最终会调用：

- `MB_RxTask(pch)`：由协议栈解析并处理整帧（Slave 处理请求并回包；Master 解析响应并释放等待）。

#### 2.3 RTU 定时器：TIM3 → 触发 `MB_RTU_TmrUpdate()`

本工程在 `mb_cfg.h` 指定：

- `MODBUS_TIMER TIM3`

在 STM32F4 端口（`Ports/STM32F4/mb_bsp.c`）中：

- `MB_RTU_TmrInit()`：`timer_open(MODBUS_TIMER, us, MB_RTU_TmrISR_Handler)`
  - 其中 `us = 1000*1000/MB_RTU_Freq`
  - 所以 `MB_Init(1000)` → `us=1000` → **1ms 周期调用一次 ISR handler**
- `MB_RTU_TmrISR_Handler()`：每次触发都会调用 `MB_RTU_TmrUpdate()`

协议栈里（`Source/mb.c`）：

- `MB_RTU_TmrUpdate()` 会对每个 RTU 通道做 `RTU_TimeoutCtr--`
- 当某通道计数减到 0，会调用 `MB_OS_RxSignal(pch)` 触发“整帧处理”

#### 2.4 Master 超时单位是什么？

`MB_CfgCh(... rx_timeout ...)` 会把 `rx_timeout` 保存到 `pch->RxTimeout`。

FreeRTOS OS 层（`OS/FreeRTOS/mb_os.c`）中，Master 等响应使用：

- `xSemaphoreTake(..., pch->RxTimeout)`

因此：

- **`rx_timeout` 的单位是 FreeRTOS Tick**
- 例如 `rx_timeout=100` 并不一定是 1 秒，除非你的 `configTICK_RATE_HZ=100`

---

### 3. 移植到你自己的 STM32 工程：最小改动清单

#### 3.1 把源码/头文件加进工程

建议保留目录结构不变，把以下目录加入编译（`.c`）并配置 include path（`.h`）：

- `Middlewares/Third_Party/uC-Modbus/Source/`
- `Middlewares/Third_Party/uC-Modbus/OS/FreeRTOS/`
- `Middlewares/Third_Party/uC-Modbus/Ports/STM32F4/`
- `Middlewares/Third_Party/uC-Modbus/Cfg/Template/`（或拷到你自己的 `UserApp` 目录以便维护）

同时确保 `mb.h` 能找到：

- `mb_cfg.h`（配置）
- `mb_os.h`（OS 层）
- `mb_cpu.h`（CPU 类型/临界区）

#### 3.2 必须实现/对接的接口（按文件看）

- **`Ports/STM32F4/mb_CPU.h`**
  - 定义 CPU 基本类型（`CPU_INTxxU/S` 等）
  - 定义临界区宏：`CPU_CRITICAL_ENTER/EXIT`
  - 本工程已补齐 `DEF_ENABLED/DEF_DISABLED`，保证配置宏可用

- **`OS/FreeRTOS/mb_os.c` / `mb_os.h`**
  - `MB_OS_Init()`：创建 Master 信号量、Slave Rx 任务与队列
  - `MB_OS_RxSignal(pch)`：在 ISR 中通知 Master/Slave
  - `MB_OS_RxWait(pch, perr)`：Master 等待响应（Tick 超时）
  - 你可以按需要调整：
    - `MB_OS_CFG_RX_TASK_PRIO`
    - `MB_OS_CFG_RX_TASK_STK_SIZE`
    - `MB_OS_RX_QUEUE_NUM`

- **`Ports/STM32F4/mb_bsp.c`（最关键）**
  - `MB_CommPortCfg()`：初始化串口并挂接 Rx/Tx 中断回调
  - `MB_CommRxIntEn/Dis()`、`MB_CommTxIntEn/Dis()`：控制 UART 中断使能
  - `MB_CommTx1()`：实际发送 1 字节（此处使用 HAL UART 发送）
  - `MB_RTU_TmrInit()` / `MB_RTU_TmrExit()` / `MB_RTU_TmrISR_Handler()`：RTU 定时器对接

> 注意：本工程的 `mb_bsp.c` 依赖 `shLib_F4` 的 `serial_*` 与 `timer_*`，如果你不用 `shLib_F4`，需要把这些调用替换成你工程自己的 HAL/LL 驱动实现。

#### 3.3 RS485 DE/RE（方向控制）怎么做？

uC/Modbus 协议栈本身不关心 RS485 的 DE/RE 控制；你需要在“串口发送前/发送后”切换方向。

本工程的 `shLib_F4` 在 `shUsart.c` 里已经有 485 控制能力（通过 `Serial[num].RW_PIN` 与 `RW_Ctrl_WriteEnable/ReadEnable()` 切换）。

推荐做法：

- 在初始化串口时，为对应 `serialX` 绑定 RW 控制脚（例如 `PD4/PD10`）
- 在 Tx 开始/结束中断或发送函数前后切换方向

工程里 `UserApp/main.c` 还保留了一个注释掉的调用：

- `mbTask_Great_RWctrl(...)`

如果你要做标准的 RS485 半双工，一定要把方向控制串起来，否则会出现“发送有波形但对端收不到/自己收不到回包”的问题。

---

### 4. 常见移植问题排查

- **从机不响应**
  - 是否调用了 `MB_Init()`、并且 RTU 定时器在跑（`MB_RTU_TmrISR_Handler()` 能被周期调用）
  - `MB_CfgCh()` 的 node_addr 是否与上位机请求一致
  - 串口 Rx 中断是否真的调用到了 `MB_RxByte()`
  - Slave Rx 任务是否在运行（`OS/FreeRTOS/mb_os.c` 创建的 RX 任务）

- **主机一直超时**
  - `rx_timeout` 单位是 FreeRTOS Tick（不是“毫秒/秒”固定单位）
  - 串口 Tx/Rx 回调是否挂接成功（`serial_attachRxInterrupt/serial_attachTxInterrupt`）
  - RS485 方向控制是否正确（发送后是否切回接收）

- **寄存器读写不对**
  - `mbreg.h` 定义了地址范围
  - `mb_data.c` 的回调函数决定读写行为（你必须按自己的变量/IO 做映射）

